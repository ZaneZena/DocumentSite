import{_ as s,c as a,o as i,a3 as t}from"./chunks/framework.C_bjHMch.js";const u=JSON.parse('{"title":"Docker","description":"","frontmatter":{},"headers":[],"relativePath":"serverend/docker.md","filePath":"serverend/docker.md"}'),e={name:"serverend/docker.md"},l=t(`<h1 id="docker" tabindex="-1">Docker <a class="header-anchor" href="#docker" aria-label="Permalink to &quot;Docker&quot;">​</a></h1><blockquote><p>虚拟化容器 ，Docker 是基于 Go 语言实现的开源容器项目 它诞生于 2013 年年初 。</p><p>Docker 的构想是要实现“ Build Ship and Run Any App, Anywhere ”，即通过对应用的封装（ Packaging ）、分发（ Distribution ）、部署（ Deployment ）、运行（ Runtime ）生命周期进行管理，达到应用组件级别的“一次封装 ，到处运行”</p><p>Docker 提供了高效、敏捷和轻量级的容器方案，并支持部署到本地环境和多种主流云平台 可以说 Docker 首次为应用的开发 、运行和部署提供了“ 一站式”的实用解决方案。</p></blockquote><h2 id="docker-的优势" tabindex="-1">Docker 的优势 <a class="header-anchor" href="#docker-的优势" aria-label="Permalink to &quot;Docker 的优势&quot;">​</a></h2><ul><li>快速分发和部署</li><li>通过容器来打包应用、解藕应用和运行平台</li><li>更高效的资源利用。 Docker 是内核级的虚拟化，可以实现更高的性能，同时对资源的额外需求很低 与传统虚拟机方式相比， Docker 的性能要提高 1 ~ 2 个数量级</li><li>更轻松的迁移和扩展。Docker 容器几乎可以在任意的平台上运行，包括物理机、虚拟机、公有云、私有云 个人电脑 服务器等</li><li>更简单的更新管理。 使用 Dockerfile ，只需要小小的配置修改，就可以替代以往大量的更新工作 所有修改都以增量的方式被分发和更新，从而实现自动化并且高效的容器管理</li></ul><br><h2 id="docker-和-传统虚拟机-比较" tabindex="-1">Docker 和 传统虚拟机 比较 <a class="header-anchor" href="#docker-和-传统虚拟机-比较" aria-label="Permalink to &quot;Docker 和 传统虚拟机 比较&quot;">​</a></h2><table tabindex="0"><thead><tr><th style="text-align:left;">特征</th><th>容器</th><th>虚拟机</th></tr></thead><tbody><tr><td style="text-align:left;">启动速度</td><td>秒级</td><td>分钟级</td></tr><tr><td style="text-align:left;">性能</td><td>接近原生</td><td>较弱</td></tr><tr><td style="text-align:left;">内存代价</td><td>很小</td><td>较多</td></tr><tr><td style="text-align:left;">硬盘使用</td><td>一般为 MB</td><td>一般为 GB</td></tr><tr><td style="text-align:left;">运行密度</td><td>单机支持上千个容器</td><td>一般几十个</td></tr><tr><td style="text-align:left;">隔离性</td><td>安全隔离</td><td>完全隔离</td></tr><tr><td style="text-align:left;">迁移性</td><td>优秀</td><td>一般</td></tr></tbody></table><h2 id="三大核心" tabindex="-1">三大核心 <a class="header-anchor" href="#三大核心" aria-label="Permalink to &quot;三大核心&quot;">​</a></h2><ul><li><p>镜像</p><blockquote><p>Docker 镜像类似于虚拟机镜像，可以将它理解为一个只读的模板。</p><p>镜像是创建 Docker 容器的基础</p></blockquote></li><li><p>容器</p><blockquote><p>Docker 容器类似于一个轻量级的沙箱， Docker 利用容器来运行和隔离应用</p><p>容器是从镜像创建的应用运行实例 它可以启动、开始、停止 删除，而这些容器都是彼此相互隔离、互不可见的</p></blockquote></li><li><p>仓库</p><blockquote><p>Docker 仓库类似于代码仓库，是 Docker 集中存放镜像文件的场所。</p></blockquote></li></ul><h2 id="docker-安装" tabindex="-1">Docker 安装 <a class="header-anchor" href="#docker-安装" aria-label="Permalink to &quot;Docker 安装&quot;">​</a></h2><ul><li><p>Ubuntu 上安装 docker</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>sudo  apt install docker.io</span></span></code></pre></div></li></ul><h2 id="镜像-image-的基本操作" tabindex="-1">镜像 image 的基本操作 <a class="header-anchor" href="#镜像-image-的基本操作" aria-label="Permalink to &quot;镜像 image 的基本操作&quot;">​</a></h2><ol><li>搜索镜像</li></ol><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>docket search name</span></span></code></pre></div><ol start="2"><li>获取镜像</li></ol><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>docker  pull  name[:tag]</span></span></code></pre></div><blockquote><p>如果不显式指定 tag , 则默认 拉去 latest 版本、 镜像的 latest 版本意味着该镜像的内容会跟踪最新版本的变更而变化，内容是不稳定的。</p></blockquote><ol start="3"><li>查看本地镜像信息</li></ol><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>docker  images   </span></span>
<span class="line"><span>docker  image  ls</span></span></code></pre></div><ol start="4"><li>删除镜像</li></ol><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>docker image rm  [-f] name[:tag]</span></span></code></pre></div><ol start="5"><li>导出镜像文件到本地</li></ol><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>docker  save  -o  &lt;导出的文件名.tar&gt;  -output &lt;存储的路径&gt;   name[:tag]</span></span></code></pre></div><ol start="6"><li>导入镜像</li></ol><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>docker  load  -i  &lt;导入的文件名&gt; -input &lt;导入的路径&gt;</span></span></code></pre></div><ol start="7"><li>创建镜像</li></ol><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>docker  build  -t  &lt;repository&gt;:&lt;tag&gt;  &lt;dest&gt; </span></span>
<span class="line"><span></span></span>
<span class="line"><span>docker build -t  haredot/qikux:1.0  .</span></span></code></pre></div><blockquote><p>-t 列表 tag 标签列表</p><p>-build-arg : 设置 编译镜像需要用到的参数、可以覆盖 ARG 中指定的默认值</p></blockquote><h3 id="基于dockerfile-创建镜像-image" tabindex="-1">基于Dockerfile 创建镜像 image <a class="header-anchor" href="#基于dockerfile-创建镜像-image" aria-label="Permalink to &quot;基于Dockerfile 创建镜像 image&quot;">​</a></h3><ul><li><p>FROM : 创建镜像的基础镜像</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>FROM   openjdk:17</span></span></code></pre></div></li></ul><blockquote><p>FROM 配置指令 必须出现在 Dockerfile 的第一行命令中， 一个镜像只能有一个 FROM, 但一个 Dockerfile 中 可以配置多个 镜像， 定义多个 FROM</p></blockquote><ul><li><p>ARG : 定义创建镜像过程中使用的变量</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>ARG  JAR_FILE=qikux.jar</span></span></code></pre></div><blockquote><p>设置 临时变量及 默认值。 在执行 docker builder 命令的时候，可以通过 -build-arg 给变量赋值 、 当 镜像编译成功后， ARG 定义的变量 将不再存在。</p></blockquote></li><li><p>LABEL : 定义镜像的元数据标签信息</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>LABEL  kundianhuo@sina.com  haredot</span></span></code></pre></div></li><li><p>EXPOSE : 声明 镜像内 服务监听的 端口 (可以监听多个端口、以 空格分隔)</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>EXPOSE  8080</span></span></code></pre></div></li><li><p>ENV : 指定环境变量</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>ENV APP_version=l.0</span></span></code></pre></div><blockquote><p>和 ARG 不同的时候， 镜像编译后，该变量依旧存在。</p></blockquote></li><li><p>WORKDIR</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>WORKDIR /path/to/workdir</span></span></code></pre></div><blockquote><p>为后续的 RUN ， CMD ， ENTRYPOINT 指令配置工作目录 , 后续命令中如果使用 相对路径， 会生效。</p></blockquote></li><li><p>ENTRYPOINT : 镜像默认 入口命令</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>ENTRYPOINT  [&quot;java&quot;,  &quot;-jar&quot; ,  &quot;qikux.jar&quot;]</span></span></code></pre></div><blockquote><p>每个 Dockerfile 中 只能由一个 ENTRYPOINT , 当指定多个的时候，最后一个生效。</p><p>ENTRYPOINT 支持两种格式：</p><ol><li>ENTRYPOINT [&quot;executable&quot;, &quot;paraml &quot;, &quot;param2&quot;] 使用 exec 方式执行</li><li>ENTRYPOINT command param 1 param2 使用 shell 中执行</li></ol></blockquote></li><li><p>VOLUME : 生成一个数据卷挂载点</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>VOLUME  /temp</span></span></code></pre></div><blockquote><p>运行容器时可以从本地主机或其他容器挂载数据卷， 一般用来存放数据库和需要保存的文件等</p></blockquote></li><li><p>USER : 指定 运行容器时的用户 或 用户ID</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>USER  haredot</span></span></code></pre></div></li><li><p>RUN : 运行指定的命令</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>RUN  apt install mysql</span></span></code></pre></div></li><li><p>CMD : 启动容器时，默认执行的命令</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>CMD  [&quot;java&quot; , &quot;-jar&quot;,  &quot;qikux.jar&quot;]</span></span></code></pre></div><blockquote><p>CMD 指令用来指定启动容器时默认执行的命令, 每个 Dockerfile 中 只能由一个CMD , 当指定多个的时候，最后一个生效。</p><p>i. CMD ［&quot;executable“，“param”， “param2” ］：相当于执行 executable param 1 param2 ，推荐方式；</p><p>ii. CMD command paraml param2 ：在默认的 Shell 中执行，提供给需要交互的应用；</p><p>iii. CMD [&quot;paraml&quot;，“param2”] ：提供给 ENTRYPOINT 的默认参数</p></blockquote></li><li><p>ADD : 添加内容到镜像</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>ADD  target/qikux-1.0.jar  /qikux.jar</span></span></code></pre></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>ADD &lt;src&gt; &lt;dest&gt; 指令 将复制指定的＜src＞路径下内容到容器中的＜dest＞路径下 ， </span></span>
<span class="line"><span>src 是 Dockerfile 所在目录 的一个相对路径 (文件/目录) 、也可以是一个 URL,  </span></span>
<span class="line"><span>还可以是一个 tar(会自动解压为目录)</span></span>
<span class="line"><span>dest  是 docker 镜像内的 绝对路径、  或者 相对于 WORKDIR 的一个 相对路径</span></span></code></pre></div></li><li><p>COPY : 复制内容到镜像</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>COPY  target/qikux-1.0.jar  /qikux.jar</span></span></code></pre></div><blockquote><p>作用和 ADD 相同、如果是拷贝本地文件，推荐使用 COPY</p></blockquote></li></ul><h3 id="dockerignore-忽略文件" tabindex="-1">.dockerignore 忽略文件 <a class="header-anchor" href="#dockerignore-忽略文件" aria-label="Permalink to &quot;.dockerignore 忽略文件&quot;">​</a></h3><blockquote><p>作用 和用法 类似于 .gitignore , 忽略 不与需要 docker 管理 文件/目录。</p><p>dockerignore 文件中模式语法支持 Golang 风格的路径正则格式：</p><p><code>*</code> ： 表示任意多个字符</p><p><code>?</code>: 表示单个字符</p><p><code>!</code> : 表示不匹配 （即不忽略指定的文件/目录）</p></blockquote><h3 id="部署-springboot-项目到-docker-步骤" tabindex="-1">部署 SpringBoot 项目到 Docker 步骤 <a class="header-anchor" href="#部署-springboot-项目到-docker-步骤" aria-label="Permalink to &quot;部署 SpringBoot 项目到 Docker 步骤&quot;">​</a></h3><ol><li><p>在 Linux 上 修改 docker 开机自启 配置文件 /usr/lib/systemd/system/docker.service 文件</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>...</span></span>
<span class="line"><span>[Service]</span></span>
<span class="line"><span>Type = notify</span></span>
<span class="line"><span>ExecStart = /usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock  -H  tcp://0.0.0.0:2375  - H unix:///var/run/docker.sock</span></span>
<span class="line"><span>...</span></span></code></pre></div></li></ol><blockquote><p>在 ExecStart 后面添加 -H tcp://0.0.0.0:2375 - H unix:///var/run/docker.sock (方便后面 idea 自动部署项目到 docker)</p></blockquote><ol start="2"><li><p>重新加载 并启动 docker</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>sudo systemctl daemon-reload</span></span>
<span class="line"><span>sudo systemctl restart docker</span></span></code></pre></div></li><li><p>在 项目的根下新建一个 Dockerfile 文件，内容如下(示例)</p><div class="language-dockerfile vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">dockerfile</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 指定镜像的基础源</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">FROM</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> openjdk:17</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 指定维护者信息</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">LABEL</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> maintainer=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;haredot2023@gmail.com 1.0&quot;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">EXPOSE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 8080</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 拷贝 jar 到 docker 中</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">COPY</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> target/qikux-zhaopin-1.0.jar /zhaopin.jar</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 指定容器启动时执行的命令</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">ENTRYPOINT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;java&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;-jar&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/zhaopin.jar&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span></code></pre></div></li><li><p>在 idea 开发工具中 安装 docker 插件 (如已安装、可自行忽略该步骤) File -&gt; settings -&gt; plugins</p></li><li><p>配置 并 链接 Linux 远程 docker File -&gt; settings -&gt; Build Exection Deployment -&gt; Docker -&gt; (点击 + 号) -&gt; 在 TCP socket 中输入 tcp://192.168.10.139:2375 （IP地址为 Linux docker所在系统的IP地址）看到 Connection Successful 即可！</p></li><li><p>在 pom.xml 中 添加 docker 插件</p><div class="language-xml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">xml</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">plugin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">groupId</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;com.spotify&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">groupId</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">artifactId</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;docker-maven-plugin&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">artifactId</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">version</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;1.2.2&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">version</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">executions</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">execution</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">id</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;build-image&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">id</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">phase</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;package&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">phase</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">goals</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">goal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;build&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">goal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">goals</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">execution</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">executions</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">configuration</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">dockerHost</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;http://192.168.10.139:2375&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">dockerHost</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">imageName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;qiku/\${project.artifactId}&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">imageName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">imageTags</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">imageTag</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;\${project.version}&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">imageTag</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">imageTags</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">forceTags</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;true&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">forceTags</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">dockerDirectory</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;\${project.basedir}&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">dockerDirectory</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">resources</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">resource</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">targetPath</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;/&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">targetPath</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">directory</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;\${project.build.directory}&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">directory</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">include</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;\${project.build.finalName}.jar&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">include</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">resource</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">resources</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">configuration</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">plugin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div></li></ol><blockquote><p>execution 配置 当 在 maven 中执行 package 命令的时候， 会自动在 docker 中 build 构建镜像</p><p>dockerHost 设置 docker 镜像 地址</p><p>imageName 设置 镜像名</p><p>imageTags 设置 镜像 Tag</p><p>dockerDirectory 设置 Dockerfile 的 路径</p><p>resource 设置 要拷贝的 jar 的路径</p></blockquote><ol start="7"><li><p>在 maven 中 执行 mvn package 命令 就会自动将 代码 部署并分发到 docker 服务中</p></li><li><p>在 docker 中 运行 系统即可</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>sudo  docker  run  -d  -p  8080:8080  --restart=always  --name haredot  qikux/&lt;artifactId&gt;:&lt;version&gt;  ;</span></span></code></pre></div></li></ol><h2 id="docker-容器-container" tabindex="-1">Docker 容器 container <a class="header-anchor" href="#docker-容器-container" aria-label="Permalink to &quot;Docker 容器 container&quot;">​</a></h2><p>Docker 中的 容器 是 镜像的 运行实例。不同的是 镜像是一个静态的 只读文件， 而容器 是 带有运行时 可写的 文件层。 容器的应用进程 处理 运行状态。</p><ul><li><p>创建容器</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>docker  create  &lt;repository&gt;:&lt;tag&gt;  ;</span></span></code></pre></div></li></ul><blockquote><p>创建一个 随机生成名字 的 容器， 也可以 通过 --name 设置容器的名字 。</p><p>使用 create 创建的容器 处于 停止状态， 可以通过 docker start 命令启动它</p></blockquote><ul><li><p>启动 容器</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>docker  start  &lt;containerName&gt; ;</span></span></code></pre></div></li></ul><blockquote><p>容器启动后，可以通过 docker ps 命令 查看 运行的 容器 信息</p></blockquote><ul><li><p>停止容器</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>docker  stop  &lt;containerName&gt; ;</span></span></code></pre></div></li><li><p>创建并运行容器</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>docker  run  -d  --name &lt;containerName&gt;  -p  8080:8080  &lt;repository&gt;:&lt;tag&gt;  --restart=always   -v  &lt;volumeName&gt;:/zhaopin/upload</span></span></code></pre></div></li></ul><blockquote><p>-d : 是否在后台运行</p><p>-p : 将 docker 容器中的 应用程序 端口 映射到 外部 指定的端口上 8080:8080 第二个 端口代表 容器中 应用程序的 端口号</p><p>--name : 设置容器的启动名称、 默认 随机 生成</p><p>--restart : 容器的重启机制 ， 默认 no , 如果 设置为 always 可以实现 docker 启动后 自动启动 该容器。</p><p>-- v : 配置数据源，用来 解决系统 上传的文件 临时存储在容器的问题。volumeName 是 数据卷的名字 。 /zhaopin/upload 是 服务器 文件上传的 前缀地址。</p></blockquote><ul><li><p>删除容器</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>docker rm  [-f]  &lt;containerName&gt; ;</span></span></code></pre></div></li></ul><blockquote><p>-f 强制删除 正在运行的 容器， 默认情况下 ，只能删除 终止 或 已退出 的容器 ， 可以通过 docker ps -a 查看所有容器的状态。</p></blockquote><ul><li><p>导出容器</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>docker export -o  xxx.tar --output &lt;导出的路径位置&gt;  &lt;containerName&gt;</span></span></code></pre></div></li><li><p>导入容器</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>docker  import xxx.tar  -  &lt;repository&gt;:&lt;tag&gt;</span></span></code></pre></div></li></ul><blockquote><p>和 docker load 命令相似, 从容器快照文件导人时可以重新指定标签等元数据信息 , 容器快照文件将丢弃所有的历史记录和元数据信息。 load 命令导入存储文件会保存完整记录、文件体积更大。</p></blockquote><ul><li><p>查看容器内进程</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>docker  top  &lt;containerName&gt; ;</span></span></code></pre></div></li><li><p>更新容器</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>docker  update  &lt;options&gt;  &lt;containerName&gt; ;</span></span></code></pre></div></li></ul><h2 id="volume-数据卷" tabindex="-1">Volume 数据卷 <a class="header-anchor" href="#volume-数据卷" aria-label="Permalink to &quot;Volume 数据卷&quot;">​</a></h2><blockquote><p>在Docker中，容器的文件系统是临时性的，默认情况下，当您删除容器时，容器中的所有上传文件数据都会丢失。要解决这个问题 有以下几种方案</p><ol><li>数据卷： Docker 提供了数据卷的功能，它可以将容器中的特定目录或文件与主机的文件系统目录进行映射，从而使数据持久化存储，即使容器被删除，数据仍然保留在主机上。</li><li>命名数据卷</li><li>外部存储服务， 例如 OSS</li><li>数据备份</li></ol></blockquote><ul><li><p>创建数据卷</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>docker volume create &lt;volumnName&gt;</span></span></code></pre></div></li><li><p>删除数据卷</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>docker  volume rm  &lt;volumnName&gt;</span></span></code></pre></div></li><li><p>查看数据卷详情</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>docker volume  inspect  &lt;volumnName&gt;</span></span></code></pre></div></li><li><p>查看所有数据卷</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>docker volume ls</span></span></code></pre></div></li></ul>`,56),p=[l];function n(o,h,d,k,c,r){return i(),a("div",null,p)}const E=s(e,[["render",n]]);export{u as __pageData,E as default};
